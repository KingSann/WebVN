webvn.use(["webgl"], function (webgl) { webgl.fragShader.create({
    "colorMatrix": "#ifdef GL_ES\r\n    precision mediump float;\r\n#endif\r\n\r\nvarying vec2 v_Uv;\r\nuniform sampler2D u_Sampler;\r\nuniform float m[20];\r\n\r\nvoid main() {\r\n    vec4 c = texture2D(u_Sampler, v_Uv);\r\n    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];\r\n    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];\r\n    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];\r\n    gl_FragColor.a = m[15] * c.r + m[16] * c.g + m[17] * c.b + m[18] * c.a + m[19];\r\n}",
    "convolution": "precision mediump float;\r\nvarying vec2 v_Uv;\r\nuniform sampler2D u_Sampler;\r\nuniform vec2 u_Px;\r\nuniform float m[9];\r\nvoid main(void) {\r\n    vec4 c11 = texture2D(u_Sampler, v_Uv - u_Px);\r\n    vec4 c12 = texture2D(u_Sampler, vec2(v_Uv.x, v_Uv.y - u_Px.y));\r\n    vec4 c13 = texture2D(u_Sampler, vec2(v_Uv.x + u_Px.x, v_Uv.y - u_Px.y));\r\n    vec4 c21 = texture2D(u_Sampler, vec2(v_Uv.x - u_Px.x, v_Uv.y));\r\n    vec4 c22 = texture2D(u_Sampler, v_Uv);\r\n    vec4 c23 = texture2D(u_Sampler, vec2(v_Uv.x + u_Px.x, v_Uv.y));\r\n    vec4 c31 = texture2D(u_Sampler, vec2(v_Uv.x - u_Px.x, v_Uv.y + u_Px.y));\r\n    vec4 c32 = texture2D(u_Sampler, vec2(v_Uv.x, v_Uv.y + u_Px.y));\r\n    vec4 c33 = texture2D(u_Sampler, v_Uv + u_Px);\r\n    gl_FragColor =\r\n        c11 * m[0] + c12 * m[1] + c22 * m[2] +\r\n        c21 * m[3] + c22 * m[4] + c23 * m[5] +\r\n        c31 * m[6] + c32 * m[7] + c33 * m[8];\r\n    gl_FragColor.a = c22.a;\r\n}",
    "drawImage": "#ifdef GL_ES\r\n    precision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_Sampler;\r\nuniform float u_Alpha;\r\nvarying vec4 test;\r\nvarying vec2 v_TexCoord;\r\n\r\nvoid main() {\r\n    vec4 textureColor = texture2D(u_Sampler, v_TexCoord);\r\n    gl_FragColor = vec4(textureColor.rgb, textureColor.a * u_Alpha);\r\n}",
    "trans_HSVfade": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nvec3 hsv2rgb(vec3 c) {\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 rgb2hsv(vec3 c) {\n    const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + 0.001)), d / (q.x + 0.001), q.x);\n}\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec3 a = rgb2hsv(texture2D(from, p).rgb);\n    vec3 b = rgb2hsv(texture2D(to, p).rgb);\n    vec3 m = mix(a, b, progress);\n    vec4 r = vec4(hsv2rgb(m), mix(texture2D(from, p).a, texture2D(to, p).a, progress));\n    gl_FragColor = r;\n}",
    "trans_advancedMosaic": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nvoid main(void)\n{\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    float T = progress;\n    float S0 = 1.0;\n    float S1 = 50.0;\n    float S2 = 1.0;\n    float Half = 0.5;\n    float PixelSize = ( T < Half ) ? mix( S0, S1, T / Half ) : mix( S1, S2, (T-Half) / Half );\n    vec2 D = PixelSize / resolution.xy;\n    vec2 UV = ( p + vec2( -0.5 ) ) / D;\n    vec2 Coord = clamp( D * ( ceil( UV + vec2( -0.5 ) ) ) + vec2( 0.5 ), vec2( 0.0 ), vec2( 1.0 ) );\n    vec4 C0 = texture2D( from, Coord );\n    vec4 C1 = texture2D( to, Coord );\n    gl_FragColor = mix( C0, C1, T );\n}",
    "trans_burn": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nconst vec3 color = vec3(0.9, 0.4, 0.2);\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    gl_FragColor = mix(\n        texture2D(from, p) + vec4(progress*color, 0.0),\n        texture2D(to, p) + vec4((1.0-progress)*color, 0.0),\n        progress);\n}",
    "trans_butterflyWaveScrawler": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nconst float amplitude = 1.0;\nconst float waves = 30.0;\nconst float colorSeparation = 0.3;\nfloat PI = 3.14159265358979323846264;\nfloat compute(vec2 p, float progress, vec2 center) {\n    vec2 o = p*sin(progress * amplitude)-center;\n    vec2 h = vec2(1., 0.);\n    float theta = acos(dot(o, h)) * waves;\n    return (exp(cos(theta)) - 2.*cos(4.*theta) + pow(sin((2.*theta - PI) / 24.), 5.)) / 10.;\n}\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    float inv = 1. - progress;\n    vec2 dir = p - vec2(.5);\n    float dist = length(dir);\n    float disp = compute(p, progress, vec2(0.5, 0.5)) ;\n    vec4 texTo = texture2D(to, p + inv*disp);\n    vec4 texFrom = vec4(\n    texture2D(from, p + progress*disp*(1.0 - colorSeparation)).r,\n    texture2D(from, p + progress*disp).g,\n    texture2D(from, p + progress*disp*(1.0 + colorSeparation)).b,\n    1.0);\n    gl_FragColor = texTo*progress + texFrom*inv;\n}",
    "trans_circleOpen": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\nconst float smoothness = 0.3;\nconst bool opening = true;\nconst vec2 center = vec2(0.5, 0.5);\nconst float SQRT_2 = 1.414213562373;\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    float x = opening ? progress : 1.-progress;\n    float m = smoothstep(-smoothness, 0.0, SQRT_2*distance(center, p) - x*(1.+smoothness));\n    gl_FragColor = mix(texture2D(from, p), texture2D(to, p), opening ? 1.-m : m);\n}",
    "trans_colourDistance": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec4 fTex = texture2D(from,p);\n    vec4 tTex = texture2D(to,p);\n    gl_FragColor = mix(distance(fTex,tTex)>progress?fTex:tTex, tTex, pow(progress,5.0));\n}",
    "trans_crazyParametricFun": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nconst float a = 4.0;\nconst float b = 1.0;\nconst float amplitude = 120.0;\nconst float smoothness = 0.1;\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec2 dir = p - vec2(.5);\n    float dist = length(dir);\n    float x = (a - b) * cos(progress) + b * cos(progress * ((a / b) - 1.) );\n    float y = (a - b) * sin(progress) - b * sin(progress * ((a / b) - 1.));\n    vec2 offset = dir * vec2(sin(progress  * dist * amplitude * x), sin(progress * dist * amplitude * y)) / smoothness;\n    gl_FragColor = mix(texture2D(from, p + offset), texture2D(to, p), smoothstep(0.2, 1.0, progress));\n}",
    "trans_crossHatch": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\nconst vec2 center = vec2(0.5, 0.5);\nfloat quadraticInOut(float t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    if (progress == 0.0) {\n        gl_FragColor = texture2D(from, p);\n    } else if (progress == 1.0) {\n        gl_FragColor = texture2D(to, p);\n    } else {\n        float x = progress;\n        float dist = distance(center, p);\n        float r = x - min(rand(vec2(p.y, 0.0)), rand(vec2(0.0, p.x)));\n        float m = dist <= r ? 1.0 : 0.0;\n        gl_FragColor = mix(texture2D(from, p), texture2D(to, p), m);\n    }\n}",
    "trans_crossZoom": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nconst float PI = 3.141592653589793;\nfloat Linear_ease(in float begin, in float change, in float duration, in float time) {\n    return change * time / duration + begin;\n}\nfloat Exponential_easeInOut(in float begin, in float change, in float duration, in float time) {\n    if (time == 0.0)\n        return begin;\n    else if (time == duration)\n        return begin + change;\n    time = time / (duration / 2.0);\n    if (time < 1.0)\n        return change / 2.0 * pow(2.0, 10.0 * (time - 1.0)) + begin;\n    return change / 2.0 * (-pow(2.0, -10.0 * (time - 1.0)) + 2.0) + begin;\n}\nfloat Sinusoidal_easeInOut(in float begin, in float change, in float duration, in float time) {\n    return -change / 2.0 * (cos(PI * time / duration) - 1.0) + begin;\n}\nfloat random(in vec3 scale, in float seed) {\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\nvec3 crossFade(in vec2 uv, in float dissolve) {\n    return mix(texture2D(from, uv).rgb, texture2D(to, uv).rgb, dissolve);\n}\nvoid main() {\n    vec2 texCoord = gl_FragCoord.xy / resolution.xy;\n    vec2 center = vec2(Linear_ease(0.25, 0.5, 1.0, progress), 0.5);\n    float dissolve = Exponential_easeInOut(0.0, 1.0, 1.0, progress);\n    float strength = Sinusoidal_easeInOut(0.0, 0.4, 0.5, progress);\n    vec3 color = vec3(0.0);\n    float total = 0.0;\n    vec2 toCenter = center - texCoord;\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    for (float t = 0.0; t <= 40.0; t++) {\n        float percent = (t + offset) / 40.0;\n        float weight = 4.0 * (percent - percent * percent);\n        color += crossFade(texCoord + toCenter * percent * strength, dissolve) * weight;\n        total += weight;\n    }\n    gl_FragColor = vec4(color / total, 1.0);\n}",
    "trans_cube": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\n\nuniform float persp;\nuniform float unzoom;\nuniform float reflection;\nuniform float floating;\n\nvec2 project (vec2 p) {\n  return p * vec2(1.0, -1.2) + vec2(0.0, -floating/100.);\n}\n\nbool inBounds (vec2 p) {\n  return all(lessThan(vec2(0.0), p)) && all(lessThan(p, vec2(1.0)));\n}\n\nvec4 bgColor (vec2 p, vec2 pfr, vec2 pto) {\n  vec4 c = vec4(0.0, 0.0, 0.0, 1.0);\n  pfr = project(pfr);\n  if (inBounds(pfr)) {\n    c += mix(vec4(0.0), texture2D(from, pfr), reflection * mix(1.0, 0.0, pfr.y));\n  }\n  pto = project(pto);\n  if (inBounds(pto)) {\n    c += mix(vec4(0.0), texture2D(to, pto), reflection * mix(1.0, 0.0, pto.y));\n  }\n  return c;\n}\n\nvec2 xskew (vec2 p, float persp, float center) {\n  float x = mix(p.x, 1.0-p.x, center);\n  return (\n    (\n      vec2( x, (p.y - 0.5*(1.0-persp) * x) / (1.0+(persp-1.0)*x) )\n      - vec2(0.5-distance(center, 0.5), 0.0)\n    )\n    * vec2(0.5 / distance(center, 0.5) * (center<0.5 ? 1.0 : -1.0), 1.0)\n    + vec2(center<0.5 ? 0.0 : 1.0, 0.0)\n  );\n}\n\nvoid main() {\n  vec2 op = gl_FragCoord.xy / resolution.xy;\n  float uz = unzoom * 2.0*(0.5-distance(0.5, progress));\n  vec2 p = -uz*0.5+(1.0+uz) * op;\n  vec2 fromP = xskew(\n    (p - vec2(progress, 0.0)) / vec2(1.0-progress, 1.0),\n    1.0-mix(progress, 0.0, persp),\n    0.0\n  );\n  vec2 toP = xskew(\n    p / vec2(progress, 1.0),\n    mix(pow(progress, 2.0), 1.0, persp),\n    1.0\n  );\n  if (inBounds(fromP)) {\n    gl_FragColor = texture2D(from, fromP);\n  }\n  else if (inBounds(toP)) {\n    gl_FragColor = texture2D(to, toP);\n  }\n  else {\n    gl_FragColor = bgColor(op, fromP, toP);\n  }\n}",
    "trans_defocusBlur": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform float progress;\nuniform vec2 resolution;\nuniform sampler2D from;\nuniform sampler2D to;\nvoid main(void) {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    float T = progress;\n    float S0 = 1.0;\n    float S1 = 50.0;\n    float S2 = 1.0;\n    float Half = 0.5;\n    float PixelSize = ( T < Half ) ? mix( S0, S1, T / Half ) : mix( S1, S2, (T-Half) / Half );\n    vec2 D = PixelSize / resolution.xy;\n    vec2 UV = (gl_FragCoord.xy / resolution.xy);\n    const int NumTaps = 12;\n    vec2 Disk[NumTaps];\n    Disk[0] = vec2(-.326,-.406);\n    Disk[1] = vec2(-.840,-.074);\n    Disk[2] = vec2(-.696, .457);\n    Disk[3] = vec2(-.203, .621);\n    Disk[4] = vec2( .962,-.195);\n    Disk[5] = vec2( .473,-.480);\n    Disk[6] = vec2( .519, .767);\n    Disk[7] = vec2( .185,-.893);\n    Disk[8] = vec2( .507, .064);\n    Disk[9] = vec2( .896, .412);\n    Disk[10] = vec2(-.322,-.933);\n    Disk[11] = vec2(-.792,-.598);\n    vec4 C0 = texture2D( from, UV );\n    vec4 C1 = texture2D( to, UV );\n    for ( int i = 0; i != NumTaps; i++ )\n    {\n        C0 += texture2D( from, Disk[i] * D + UV );\n        C1 += texture2D( to, Disk[i] * D + UV );\n    }\n    C0 /= float(NumTaps+1);\n    C1 /= float(NumTaps+1);\n    gl_FragColor = mix( C0, C1, T );\n}",
    "trans_directionalWipe": "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\nconst vec2 direction = vec2(1.0, -1.0);\nconst float smoothness = 0.5;\nconst vec2 center = vec2(0.5, 0.5);\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec2 v = normalize(direction);\n    v /= abs(v.x)+abs(v.y);\n    float d = v.x * center.x + v.y * center.y;\n    float m = smoothstep(-smoothness, 0.0, v.x * p.x + v.y * p.y - (d-0.5+progress*(1.+smoothness)));\n    gl_FragColor = mix(texture2D(to, p), texture2D(from, p), m);\n}",
    "trans_dispersionBlur": "#ifdef GL_ES\nprecision mediump float;\n#endif\n#define QUALITY 32\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\nconst float GOLDEN_ANGLE = 2.399963229728653;\nvec4 blur(sampler2D t, vec2 c, float radius) {\n    vec4 sum = vec4(0.0);\n    float q = float(QUALITY);\n    for (int i=0; i<QUALITY; ++i) {\n        float fi = float(i);\n        float a = fi * GOLDEN_ANGLE;\n        float r = sqrt(fi / q) * radius;\n        vec2 p = c + r * vec2(cos(a), sin(a));\n        sum += texture2D(t, p);\n    }\n    return sum / q;\n}\nvoid main()\n{\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    float inv = 1.-progress;\n    gl_FragColor = inv*blur(from, p, progress*0.6) + progress*blur(to, p, inv*0.6);\n}",
    "trans_dissolve": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nconst float blocksize = 1.0;\nfloat rand(vec2 co) {\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    gl_FragColor = mix(texture2D(from, p), texture2D(to, p), step(rand(floor(gl_FragCoord.xy/blocksize)), progress));\n}",
    "trans_doomScreenTransition": "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nfloat rand(int num) {\n    return fract(mod(float(num) * 67123.313, 12.0) * sin(float(num) * 10.3) * cos(float(num)));\n}\nfloat wave(int num) {\n    float fn = float(num) * 1.0 * 0.1 * float(10.0);\n    return cos(fn * 0.5) * cos(fn * 0.13) * sin((fn+10.0) * 0.3) / 2.0 + 0.5;\n}\nfloat pos(int num) {\n    return wave(num);\n}\nvoid main() {\n    int bar = int(gl_FragCoord.x) / 10;\n    float scale = 1.0 + pos(bar) * 2.0;\n    float phase = progress * scale;\n    float posY = gl_FragCoord.y / resolution.y;\n    vec2 p;\n    vec4 c;\n    if (phase + posY < 1.0) {\n        p = vec2(gl_FragCoord.x, gl_FragCoord.y + mix(0.0, resolution.y, phase)) / resolution.xy;\n        c = texture2D(from, p);\n    } else {\n        p = gl_FragCoord.xy / resolution.xy;\n        c = texture2D(to, p);\n    }\n    gl_FragColor = c;\n}",
    "trans_doorway": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// General parameters\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\n \nfloat reflection = 0.4;\nfloat perspective = 0.4;\nfloat depth = 3.0;\n \nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec2 boundMin = vec2(0.0, 0.0);\nconst vec2 boundMax = vec2(1.0, 1.0);\n \nbool inBounds (vec2 p) {\n  return all(lessThan(boundMin, p)) && all(lessThan(p, boundMax));\n}\n \nvec2 project (vec2 p) {\n  return p * vec2(1.0, -1.2) + vec2(0.0, -0.02);\n}\n \nvec4 bgColor (vec2 p, vec2 pto) {\n  vec4 c = black;\n  pto = project(pto);\n  if (inBounds(pto)) {\n    c += mix(black, texture2D(to, pto), reflection * mix(1.0, 0.0, pto.y));\n  }\n  return c;\n}\n \nvoid main() {\n  vec2 p = gl_FragCoord.xy / resolution.xy;\n \n  vec2 pfr = vec2(-1.), pto = vec2(-1.);\n \n  float middleSlit = 2.0 * abs(p.x-0.5) - progress;\n  if (middleSlit > 0.0) {\n    pfr = p + (p.x > 0.5 ? -1.0 : 1.0) * vec2(0.5*progress, 0.0);\n    float d = 1.0/(1.0+perspective*progress*(1.0-middleSlit));\n    pfr.y -= d/2.;\n    pfr.y *= d;\n    pfr.y += d/2.;\n  }\n \n  float size = mix(1.0, depth, 1.-progress);\n  pto = (p + vec2(-0.5, -0.5)) * vec2(size, size) + vec2(0.5, 0.5);\n \n  if (inBounds(pfr)) {\n    gl_FragColor = texture2D(from, pfr);\n  }\n  else if (inBounds(pto)) {\n    gl_FragColor = texture2D(to, pto);\n  }\n  else {\n    gl_FragColor = bgColor(p, pto);\n  }\n}",
    "trans_dreamy": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nvec2 offset(float progress, float x, float theta) {\n    float phase = progress*progress + progress + theta;\n    float shifty = 0.03*progress*cos(10.0*(progress+x));\n    return vec2(0, shifty);\n}\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    gl_FragColor = mix(texture2D(from, p + offset(progress, p.x, 0.0)), texture2D(to, p + offset(1.0-progress, p.x, 3.14)), progress);\n}",
    "trans_fadeColorBlack": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\nconst vec3 color = vec3(0.0, 0.0, 0.0);\nconst float colorPhase = 0.4;\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    gl_FragColor = mix(\n        mix(vec4(color, 1.0), texture2D(from, p), smoothstep(1.0-colorPhase, 0.0, progress)),\n        mix(vec4(color, 1.0), texture2D(to,   p), smoothstep(    colorPhase, 1.0, progress)),\n        progress);\n    gl_FragColor.a = mix(texture2D(from, p).a, texture2D(to, p).a, progress);\n}",
    "trans_fadeGrayscale": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\nconst float grayPhase = 0.3;\nvec3 grayscale (vec3 color) {\n    return vec3(0.2126*color.r + 0.7152*color.g + 0.0722*color.b);\n}\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec4 fc = texture2D(from, p);\n    vec4 tc = texture2D(to, p);\n    gl_FragColor = mix(\n        mix(vec4(grayscale(fc.rgb), 1.0), texture2D(from, p), smoothstep(1.0-grayPhase, 0.0, progress)),\n        mix(vec4(grayscale(tc.rgb), 1.0), texture2D(to,   p), smoothstep(    grayPhase, 1.0, progress)),\n        progress);\n    gl_FragColor.a = mix(fc.a, tc.a, progress);\n}",
    "trans_finalGaussianNoise": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\n\nfloat Rand(vec2 v) {\n  return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Gaussian(float p, float center, float c) {\n  return 0.75 * exp(- pow((p - center) / c, 2.));\n}\n\nvoid main() {\n  vec2 p = gl_FragCoord.xy / resolution.xy;\n  float c = cos(Gaussian(progress * (1. + Gaussian(progress * Rand(p), 0.5, 0.5)), 0.5, 0.25));\n  vec2 d = p * c;\n  \n  gl_FragColor = mix(texture2D(from, d), texture2D(to, d), progress);\n}",
    "trans_flash": "#ifdef GL_ES\nprecision highp float;\n#endif\n \n// General parameters\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\n \nfloat flashPhase = 0.3; // if 0.0, the image directly turn grayscale, if 0.9, the grayscale transition phase is very important\nfloat flashIntensity = 3.0;\nfloat flashZoomEffect = 0.5;\n \nconst vec3 flashColor = vec3(1.0, 0.8, 0.3);\nconst float flashVelocity = 3.0;\n \nvoid main() {\n  vec2 p = gl_FragCoord.xy / resolution.xy;\n  vec4 fc = texture2D(from, p);\n  vec4 tc = texture2D(to, p);\n  float intensity = mix(1.0, 2.0*distance(p, vec2(0.5, 0.5)), flashZoomEffect) * flashIntensity * pow(smoothstep(flashPhase, 0.0, distance(0.5, progress)), flashVelocity);\n  vec4 c = mix(texture2D(from, p), texture2D(to, p), smoothstep(0.5*(1.0-flashPhase), 0.5*(1.0+flashPhase), progress));\n  c += intensity * vec4(flashColor, 1.0);\n  gl_FragColor = c;\n}",
    "trans_flyEye": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\nconst float size = 0.04;\nconst float zoom = 30.0;\nconst float colorSeparation = 0.3;\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    float inv = 1. - progress;\n    vec2 disp = size*vec2(cos(zoom*p.x), sin(zoom*p.y));\n    vec4 texTo = texture2D(to, p + inv*disp);\n    vec4 texFrom = vec4(\n        texture2D(from, p + progress*disp*(1.0 - colorSeparation)).r,\n        texture2D(from, p + progress*disp).g,\n        texture2D(from, p + progress*disp*(1.0 + colorSeparation)).b,\n        texture2D(from, p + progress*disp).a);\n    gl_FragColor = texTo*progress + texFrom*inv;\n}",
    "trans_fold": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\n\nvoid main() {\n  vec2 p = gl_FragCoord.xy / resolution.xy;\n  vec4 a = texture2D(from, (p - vec2(progress, 0.0)) / vec2(1.0-progress, 1.0));\n  vec4 b = texture2D(to, p / vec2(progress, 1.0));\n  gl_FragColor = mix(a, b, step(p.x, progress));\n}",
    "trans_glitchDisplace": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nmediump float random(vec2 co)\n{\n    mediump float a = 12.9898;\n    mediump float b = 78.233;\n    mediump float c = 43758.5453;\n    mediump float dt= dot(co.xy ,vec2(a,b));\n    mediump float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\nfloat voronoi( in vec2 x ) {\n    vec2 p = floor( x );\n    vec2 f = fract( x );\n    float res = 8.0;\n    for( float j=-1.; j<=1.; j++ )\n    for( float i=-1.; i<=1.; i++ ) {\n        vec2  b = vec2( i, j );\n        vec2  r = b - f + random( p + b );\n        float d = dot( r, r );\n        res = min( res, d );\n    }\n    return sqrt( res );\n}\nvec2 displace(vec4 tex, vec2 texCoord, float dotDepth, float textureDepth, float strength) {\n    float b = voronoi(.003 * texCoord + 2.0);\n    float g = voronoi(0.2 * texCoord);\n    float r = voronoi(texCoord - 1.0);\n    vec4 dt = tex * 1.0;\n    vec4 dis = dt * dotDepth + 1.0 - tex * textureDepth;\n    dis.x = dis.x - 1.0 + textureDepth*dotDepth;\n    dis.y = dis.y - 1.0 + textureDepth*dotDepth;\n    dis.x *= strength;\n    dis.y *= strength;\n    vec2 res_uv = texCoord ;\n    res_uv.x = res_uv.x + dis.x - 0.0;\n    res_uv.y = res_uv.y + dis.y;\n    return res_uv;\n}\nfloat ease1(float t) {\n    return t == 0.0 || t == 1.0\n        ? t\n        : t < 0.5\n        ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n        : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\nfloat ease2(float t) {\n    return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec4 color1 = texture2D(from, p);\n    vec4 color2 = texture2D(to, p);\n    vec2 disp = displace(color1, p, 0.33, 0.7, 1.0-ease1(progress));\n    vec2 disp2 = displace(color2, p, 0.33, 0.5, ease2(progress));\n    vec4 dColor1 = texture2D(to, disp);\n    vec4 dColor2 = texture2D(from, disp2);\n    float val = ease1(progress);\n    vec3 gray = vec3(dot(min(dColor2, dColor1).rgb, vec3(0.299, 0.587, 0.114)));\n    dColor2 = vec4(gray, 1.0);\n    dColor2 *= 2.0;\n    color1 = mix(color1, dColor2, smoothstep(0.0, 0.5, progress));\n    color2 = mix(color2, dColor1, smoothstep(1.0, 0.5, progress));\n    gl_FragColor = mix(color1, color2, val);\n}",
    "trans_glitchMemories": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\n\nvoid glitch_memories(sampler2D pic) {\n  vec2 p = gl_FragCoord.xy / resolution.xy;\n  vec2 block = floor(gl_FragCoord.xy / vec2(16));\n  vec2 uv_noise = block / vec2(64);\n  uv_noise += floor(vec2(progress) * vec2(1200.0, 3500.0)) / vec2(64);\n  \n  float block_thresh = pow(fract(progress * 1200.0), 2.0) * 0.2;\n  float line_thresh = pow(fract(progress * 2200.0), 3.0) * 0.7;\n  vec2 red = p, green = p, blue = p, o = p;\n  vec2 dist = (fract(uv_noise) - 0.5) * 0.3;\n  red += dist * 0.1;\n  green += dist * 0.2;\n  blue += dist * 0.125;\n  \n  gl_FragColor.r = texture2D(pic, red).r;\n  gl_FragColor.g = texture2D(pic, green).g;\n  gl_FragColor.b = texture2D(pic, blue).b;\n  gl_FragColor.a = 1.0;\n\n}\n\nvoid main(void)\n{\n  float smoothed = smoothstep(0., 1., progress);\n  if( ( smoothed < 0.4 && smoothed > 0.1) ) {\n      glitch_memories(from);\n  } else if ((smoothed > 0.6 && smoothed < 0.9) ) {\n      glitch_memories(to);\n  } else {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    gl_FragColor = mix(texture2D(from, p), texture2D(to, p), progress);\n  }\n}",
    "trans_kaleidoScope": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec2 q = p;\n    float t = pow(progress, 2.0)*1.0;\n    p = p -0.5;\n    for (int i = 0; i < 7; i++) {\n        p = vec2(sin(t)*p.x + cos(t)*p.y, sin(t)*p.y - cos(t)*p.x);\n        t += 2.0;\n        p = abs(mod(p, 2.0) - 1.0);\n    }\n    abs(mod(p, 1.0));\n    gl_FragColor = mix(\n        mix(texture2D(from, q), texture2D(to, q), progress),\n        mix(texture2D(from, p), texture2D(to, p), progress), 1.0 - 2.0*abs(progress - 0.5));\n}",
    "trans_linear": "#ifdef GL_ES\r\n  precision mediump float;\r\n#endif\r\n\r\nuniform sampler2D from, to;\r\nuniform float progress;\r\nuniform vec2 resolution;\r\n\r\nvoid main() {\r\n  vec2 p = gl_FragCoord.xy / resolution.xy;\r\n  gl_FragColor = mix(texture2D(from, p), texture2D(to, p), progress);\r\n}",
    "trans_linearBlur": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nconst float intensity = 0.1;\nconst int PASSES = 8;\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec4 c1 = vec4(0.0), c2 = vec4(0.0);\n    float disp = intensity*(0.5-distance(0.5, progress));\n    for (int xi=0; xi<PASSES; ++xi) {\n        float x = float(xi) / float(PASSES) - 0.5;\n        for (int yi=0; yi<PASSES; ++yi) {\n            float y = float(yi) / float(PASSES) - 0.5;\n            vec2 v = vec2(x,y);\n            float d = disp;\n            c1 += texture2D(from, p + d*v);\n            c2 += texture2D(to, p + d*v);\n        }\n    }\n    c1 /= float(PASSES*PASSES);\n    c2 /= float(PASSES*PASSES);\n    gl_FragColor = mix(c1, c2, progress);\n}",
    "trans_morph": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nconst float strength=0.1;\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec4 ca = texture2D(from, p);\n    vec4 cb = texture2D(to, p);\n    vec2 oa = (((ca.rg+ca.b)*0.5)*2.0-1.0);\n    vec2 ob = (((cb.rg+cb.b)*0.5)*2.0-1.0);\n    vec2 oc = mix(oa,ob,0.5)*strength;\n    float w0 = progress;\n    float w1 = 1.0-w0;\n    gl_FragColor = mix(texture2D(from, p+oc*w0), texture2D(to, p-oc*w1), progress);\n}",
    "trans_pageCurl": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\n\nconst float MIN_AMOUNT = -0.16;\nconst float MAX_AMOUNT = 1.3;\nfloat amount = progress * (MAX_AMOUNT - MIN_AMOUNT) + MIN_AMOUNT;\n\nconst float PI = 3.141592653589793;\n\nconst float scale = 512.0;\nconst float sharpness = 3.0;\n\nfloat cylinderCenter = amount;\nfloat cylinderAngle = 2.0 * PI * amount;\n\nconst float cylinderRadius = 1.0 / PI / 2.0;\n\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation)\n{\n    float hitPoint = hitAngle / (2.0 * PI);\n    point.y = hitPoint;\n    return rrotation * point;\n}\n\nvec4 antiAlias(vec4 color1, vec4 color2, float distanc)\n{\n    distanc *= scale;\n    if (distanc < 0.0) return color2;\n    if (distanc > 2.0) return color1;\n    float dd = pow(1.0 - distanc / 2.0, sharpness);\n    return ((color2 - color1) * dd) + color1;\n}\n\nfloat distanceToEdge(vec3 point)\n{\n    float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n    float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n    if (point.x < 0.0) dx = -point.x;\n    if (point.x > 1.0) dx = point.x - 1.0;\n    if (point.y < 0.0) dy = -point.y;\n    if (point.y > 1.0) dy = point.y - 1.0;\n    if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n    return min(dx, dy);\n}\n\nvec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation)\n{\n    float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\n    vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n    if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0))\n    {\n      vec2 texCoord = gl_FragCoord.xy / resolution.xy;\n        return texture2D(to, texCoord);\n    }\n\n    if (yc > 0.0) return texture2D(from, p);\n\n    vec4 color = texture2D(from, point.xy);\n    vec4 tcolor = vec4(0.0);\n\n    return antiAlias(color, tcolor, distanceToEdge(point));\n}\n\nvec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation)\n{\n    float shadow = distanceToEdge(point) * 30.0;\n    shadow = (1.0 - shadow) / 3.0;\n\n    if (shadow < 0.0) shadow = 0.0; else shadow *= amount;\n\n    vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);\n    shadowColor.r -= shadow;\n    shadowColor.g -= shadow;\n    shadowColor.b -= shadow;\n\n    return shadowColor;\n}\n\nvec4 backside(float yc, vec3 point)\n{\n    vec4 color = texture2D(from, point.xy);\n    float gray = (color.r + color.b + color.g) / 15.0;\n    gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\n    color.rgb = vec3(gray);\n    return color;\n}\n\nvec4 behindSurface(float yc, vec3 point, mat3 rrotation)\n{\n    float shado = (1.0 - ((-cylinderRadius - yc) / amount * 7.0)) / 6.0;\n    shado *= 1.0 - abs(point.x - 0.5);\n\n    yc = (-cylinderRadius - cylinderRadius - yc);\n\n    float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n    point = hitPoint(hitAngle, yc, point, rrotation);\n\n    if (yc < 0.0 && point.x >= 0.0 && point.y >= 0.0 && point.x <= 1.0 && point.y <= 1.0 && (hitAngle < PI || amount > 0.5))\n    {\n        shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / (71.0 / 100.0));\n        shado *= pow(-yc / cylinderRadius, 3.0);\n        shado *= 0.5;\n    }\n    else\n    {\n        shado = 0.0;\n    }\n    \n    vec2 texCoord = gl_FragCoord.xy / resolution.xy;\n\n    return vec4(texture2D(to, texCoord).rgb - shado, 1.0);\n}\n\nvoid main()\n{\n  vec2 texCoord = gl_FragCoord.xy / resolution.xy;\n  \n  const float angle = 30.0 * PI / 180.0;\n    float c = cos(-angle);\n    float s = sin(-angle);\n\n    mat3 rotation = mat3( c, s, 0,\n                                -s, c, 0,\n                                0.12, 0.258, 1\n                                );\n    c = cos(angle);\n    s = sin(angle);\n\n    mat3 rrotation = mat3(  c, s, 0,\n                                    -s, c, 0,\n                                    0.15, -0.5, 1\n                                );\n\n    vec3 point = rotation * vec3(texCoord, 1.0);\n\n    float yc = point.y - cylinderCenter;\n\n    if (yc < -cylinderRadius)\n    {\n        // Behind surface\n        gl_FragColor = behindSurface(yc, point, rrotation);\n        return;\n    }\n\n    if (yc > cylinderRadius)\n    {\n        // Flat surface\n        gl_FragColor = texture2D(from, texCoord);\n        return;\n    }\n\n    float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n\n    float hitAngleMod = mod(hitAngle, 2.0 * PI);\n    if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0))\n    {\n        gl_FragColor = seeThrough(yc, texCoord, rotation, rrotation);\n        return;\n    }\n\n    point = hitPoint(hitAngle, yc, point, rrotation);\n\n    if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0)\n    {\n        gl_FragColor = seeThroughWithShadow(yc, texCoord, point, rotation, rrotation);\n        return;\n    }\n\n    vec4 color = backside(yc, point);\n\n    vec4 otherColor;\n    if (yc < 0.0)\n    {\n        float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\n        shado *= pow(-yc / cylinderRadius, 3.0);\n        shado *= 0.5;\n        otherColor = vec4(0.0, 0.0, 0.0, shado);\n    }\n    else\n    {\n        otherColor = texture2D(from, texCoord);\n    }\n\n    color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n\n    vec4 cl = seeThroughWithShadow(yc, texCoord, point, rotation, rrotation);\n    float dist = distanceToEdge(point);\n\n    gl_FragColor = antiAlias(color, cl, dist);\n}",
    "trans_pinWheel": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\n\nvoid main() {\n  \n  vec2 p = gl_FragCoord.xy / resolution.xy;\n  \n  float circPos = atan(p.y - 0.5, p.x - 0.5) + progress;\n  float modPos = mod(circPos, 3.1415 / 4.);\n  float signed = sign(progress - modPos);\n  float smoothed = smoothstep(0., 1., signed);\n  \n  if (smoothed > 0.5){\n    gl_FragColor = texture2D(to, p);\n  } else {\n    gl_FragColor = texture2D(from, p);\n  }\n  \n}\n",
    "trans_pixelize": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\nconst ivec2 size = ivec2(10.0, 10.0);\nconst float smoothness = 0.5;\nfloat rand (vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    float r = rand(floor(vec2(size) * p));\n    float m = smoothstep(0.0, -smoothness, r - (progress * (1.0 + smoothness)));\n    gl_FragColor = mix(texture2D(from, p), texture2D(to, p), m);\n}",
    "trans_polkaDots": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nconst float dots = 5.0;\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    float x = progress;\n    bool nextImage = distance(fract(p * dots), vec2(0.5, 0.5)) < x;\n    if(nextImage)\n        gl_FragColor = texture2D(to, p);\n    else\n        gl_FragColor = texture2D(from, p);\n}",
    "trans_polkaDotsCurtain": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nconst float SQRT_2 = 1.414213562373;\nconst float dots = 20.0;\nconst vec2 center = vec2(1.0, 1.0);\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    float x = progress /2.0;\n    bool nextImage = distance(fract(p * dots), vec2(0.5, 0.5)) < (2.0 * x / distance(p, center));\n    if(nextImage) gl_FragColor = texture2D(to, p);\n    else gl_FragColor = texture2D(from, p);\n}",
    "trans_radial": "#ifdef GL_ES\nprecision mediump float;\n#endif\n#define PI 3.141592653589\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec2 rp = p*2.-1.;\n    float a = atan(rp.y, rp.x);\n    float pa = progress*PI*2.5-PI*1.25;\n    vec4 fromc = texture2D(from, p);\n    vec4 toc = texture2D(to, p);\n    if(a>pa) {\n        gl_FragColor = mix(toc, fromc, smoothstep(0., 1., (a-pa)));\n    } else {\n        gl_FragColor = toc;\n    }\n}",
    "trans_randomSquares": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvoid main() {\n    float revProgress = (1.0 - progress);\n    float distFromEdges = min(progress, revProgress);\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec4 fromColor = texture2D(from, p);\n    vec4 toColor = texture2D(to, p);\n    float squareSize = 20.0;\n    float flickerSpeed = 60.0;\n    vec2 seed = floor(gl_FragCoord.xy / squareSize) * floor(distFromEdges * flickerSpeed);\n    gl_FragColor = mix(fromColor, toColor, progress) + rand(seed) * distFromEdges * 0.5;\n}",
    "trans_ripple": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\nconst float amplitude = 100.0;\nconst float speed = 50.0;\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec2 dir = p - vec2(.5);\n    float dist = length(dir);\n    vec2 offset = dir * (sin(progress * dist * amplitude - progress * speed) + .5) / 30.;\n    gl_FragColor = mix(texture2D(from, p + offset), texture2D(to, p), smoothstep(0.2, 1.0, progress));\n}",
    "trans_simpleFlip": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\n\nvoid main() {\n  vec2 p = gl_FragCoord.xy / resolution.xy;\n  vec2 q = p;\n  p.x = (p.x - 0.5)/abs(progress - 0.5)*0.5 + 0.5;\n  vec4 a = texture2D(from, p);\n  vec4 b = texture2D(to, p);\n  gl_FragColor = vec4(mix(a, b, step(0.5, progress)).rgb * step(abs(q.x - 0.5), abs(progress - 0.5)), 1.0);\n}",
    "trans_slide": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\n\nfloat translateX = 1.0;\nfloat translateY = 0.0;\n\nvoid main() {\n    vec2 texCoord = gl_FragCoord.xy / resolution.xy;\n    float x = progress * translateX;\n    float y = progress * translateY;\n\n    if (x >= 0.0 && y >= 0.0) {\n        if (texCoord.x >= x && texCoord.y >= y) {\n            gl_FragColor = texture2D(from, texCoord - vec2(x, y));\n        }\n        else {\n            vec2 uv;\n            if (x > 0.0)\n                uv = vec2(x - 1.0, y);\n            else if (y > 0.0)\n                uv = vec2(x, y - 1.0);\n            gl_FragColor = texture2D(to, texCoord - uv);\n        }\n    }\n    else if (x <= 0.0 && y <= 0.0) {\n        if (texCoord.x <= (1.0 + x) && texCoord.y <= (1.0 + y))\n            gl_FragColor = texture2D(from, texCoord - vec2(x, y));\n        else {\n            vec2 uv;\n            if (x < 0.0)\n                uv = vec2(x + 1.0, y);\n            else if (y < 0.0)\n                uv = vec2(x, y + 1.0);\n            gl_FragColor = texture2D(to, texCoord - uv);\n        }\n    }\n    else\n        gl_FragColor = vec4(0.0);\n}",
    "trans_squareSwipe": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\nconst ivec2 squares = ivec2(10.0, 10.0);\nconst vec2 direction = vec2(1.0, -0.5);\nconst float smoothness = 1.6;\nconst vec2 center = vec2(0.5, 0.5);\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec2 v = normalize(direction);\n    if (v != vec2(0.0))\n        v /= abs(v.x)+abs(v.y);\n    float d = v.x * center.x + v.y * center.y;\n    float offset = smoothness;\n    float pr = smoothstep(-offset, 0.0, v.x * p.x + v.y * p.y - (d-0.5+progress*(1.+offset)));\n    vec2 squarep = fract(p*vec2(squares));\n    vec2 squaremin = vec2(pr/2.0);\n    vec2 squaremax = vec2(1.0 - pr/2.0);\n    float a = all(lessThan(squaremin, squarep)) && all(lessThan(squarep, squaremax)) ? 1.0 : 0.0;\n    gl_FragColor = mix(texture2D(from, p), texture2D(to, p), a);\n}",
    "trans_squeeze": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\nconst float colorSeparation = 0.02;\nfloat progressY (float y) {\n    return 0.5 + (y-0.5) / (1.0-progress);\n}\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    float y = progressY(p.y);\n    if (y < 0.0 || y > 1.0) {\n        gl_FragColor = texture2D(to, p);\n    }\n    else {\n        vec2 fp = vec2(p.x, y) + progress*vec2(0.0, colorSeparation);\n        vec4 c = vec4(\n            texture2D(from, fp).r,\n            texture2D(from, fp).g,\n            texture2D(from, fp).b,\n            texture2D(from, fp).a\n            );\n        gl_FragColor = c;\n        if (c.a == 0.0) {gl_FragColor = texture2D(to, p);}\n    }\n}",
    "trans_starWipe": "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\n\nvec2 circlePoint( float ang )\n{\n  ang += 6.28318 * 0.15;\n  return vec2( cos(ang), sin(ang) );  \n}\n\nfloat cross2d( vec2 a, vec2 b )\n{\n  return ( a.x * b.y - a.y * b.x );\n}\n\n// quickly knocked together with some math from http://www.pixeleuphoria.com/node/30\nfloat star( vec2 p, float size )\n{\n  if( size <= 0.0 )\n  {\n    return 0.0;\n  }\n  p /= size;\n  \n  vec2 p0 = circlePoint( 0.0 );\n  vec2 p1 = circlePoint( 6.28318 * 1.0 / 5.0 );\n  vec2 p2 = circlePoint( 6.28318 * 2.0 / 5.0 );\n  vec2 p3 = circlePoint( 6.28318 * 3.0 / 5.0 );\n  vec2 p4 = circlePoint( 6.28318 * 4.0 / 5.0 );\n  \n  // are we on this side of the line\n  float s0 = ( cross2d( p1 - p0, p - p0 ) );\n  float s1 = ( cross2d( p2 - p1, p - p1 ) );\n  float s2 = ( cross2d( p3 - p2, p - p2 ) );\n  float s3 = ( cross2d( p4 - p3, p - p3 ) );\n  float s4 = ( cross2d( p0 - p4, p - p4 ) );\n  \n  // some trial and error math to get the star shape.  I'm sure there's some elegance I'm missing.\n  float s5 = min( min( min( s0, s1 ), min( s2, s3 ) ), s4 );\n  float s = max( 1.0 - sign( s0 * s1 * s2 * s3 * s4 ) + sign(s5), 0.0 );\n  s = sign( 2.6 - length(p) ) * s;\n  \n  return max( s, 0.0 );\n}\n\nvoid main() \n{\n  vec2 p = ( gl_FragCoord.xy / resolution.xy );\n  vec2 o = p * 2.0 - 1.0;\n  \n  float t = progress * 1.4;\n  \n  float c1 = star( o, t );\n  float c2 = star( o, t - 0.1 );\n  \n  float border = max( c1 - c2, 0.0 );\n  \n  gl_FragColor = mix(texture2D(from, p), texture2D(to, p), c1) + vec4( border, border, border, 0.0 );\n}",
    "trans_swap": "#ifdef GL_ES\nprecision mediump float;\n#endif\n \n// General parameters\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\n \nfloat reflection = 0.4;\nfloat perspective = 0.2;\nfloat depth = 3.0;\n \nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec2 boundMin = vec2(0.0, 0.0);\nconst vec2 boundMax = vec2(1.0, 1.0);\n \nbool inBounds (vec2 p) {\n  return all(lessThan(boundMin, p)) && all(lessThan(p, boundMax));\n}\n \nvec2 project (vec2 p) {\n  return p * vec2(1.0, -1.2) + vec2(0.0, -0.02);\n}\n \nvec4 bgColor (vec2 p, vec2 pfr, vec2 pto) {\n  vec4 c = black;\n  pfr = project(pfr);\n  if (inBounds(pfr)) {\n    c += mix(black, texture2D(from, pfr), reflection * mix(1.0, 0.0, pfr.y));\n  }\n  pto = project(pto);\n  if (inBounds(pto)) {\n    c += mix(black, texture2D(to, pto), reflection * mix(1.0, 0.0, pto.y));\n  }\n  return c;\n}\n \nvoid main() {\n  vec2 p = gl_FragCoord.xy / resolution.xy;\n \n  vec2 pfr, pto = vec2(-1.);\n \n  float size = mix(1.0, depth, progress);\n  float persp = perspective * progress;\n  pfr = (p + vec2(-0.0, -0.5)) * vec2(size/(1.0-perspective*progress), size/(1.0-size*persp*p.x)) + vec2(0.0, 0.5);\n \n  size = mix(1.0, depth, 1.-progress);\n  persp = perspective * (1.-progress);\n  pto = (p + vec2(-1.0, -0.5)) * vec2(size/(1.0-perspective*(1.0-progress)), size/(1.0-size*persp*(0.5-p.x))) + vec2(1.0, 0.5);\n \n  bool fromOver = progress < 0.5;\n \n  if (fromOver) {\n    if (inBounds(pfr)) {\n      gl_FragColor = texture2D(from, pfr);\n    }\n    else if (inBounds(pto)) {\n      gl_FragColor = texture2D(to, pto);\n    }\n    else {\n      gl_FragColor = bgColor(p, pfr, pto);\n    }\n  }\n  else {\n    if (inBounds(pto)) {\n      gl_FragColor = texture2D(to, pto);\n    }\n    else if (inBounds(pfr)) {\n      gl_FragColor = texture2D(from, pfr);\n    }\n    else {\n      gl_FragColor = bgColor(p, pfr, pto);\n    }\n  }\n}",
    "trans_swirl": "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D from, to;\nuniform float progress;\nuniform vec2 resolution;\n\n/*\n  (C) Sergey Kosarevsky, 2014\n  \n  Available under the terms of MIT license\n  http://www.linderdaum.com\n*/\n\nvoid main(void)\n{\n    float Radius = 1.0;\n\n    float T = progress;\n\n    vec2 UV = gl_FragCoord.xy / resolution.xy;\n\n    UV -= vec2( 0.5, 0.5 );\n\n    float Dist = length(UV);\n\n    if ( Dist < Radius )\n    {\n        float Percent = (Radius - Dist) / Radius;\n        float A = ( T <= 0.5 ) ? mix( 0.0, 1.0, T/0.5 ) : mix( 1.0, 0.0, (T-0.5)/0.5 );\n        float Theta = Percent * Percent * A * 8.0 * 3.14159;\n        float S = sin( Theta );\n        float C = cos( Theta );\n        UV = vec2( dot(UV, vec2(C, -S)), dot(UV, vec2(S, C)) );\n    }\n    UV += vec2( 0.5, 0.5 );\n\n    vec4 C0 = texture2D( from, UV );\n    vec4 C1 = texture2D( to, UV );\n\n    gl_FragColor = mix( C0, C1, T );\n}\n",
    "trans_undulatingBurnOut": "#ifdef GL_ES\n    precision mediump float;\n#endif\n\n#define M_PI 3.14159265358979323846\n\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\n \nuniform float smoothness;\nconst vec2 center = vec2(0.5, 0.5);\n\nfloat quadraticInOut(float t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat linearInterp(vec2 range, vec2 domain, float x) {\n    return mix(range.x, range.y, smoothstep(domain.x, domain.y, clamp(x, domain.x, domain.y)));\n}\n\nfloat getGradient(float r, float dist) {\n    float grad = smoothstep(-smoothness, 0.0, r - dist * (1.0 + smoothness)); //, 0.0, 1.0);\n    if (r - dist < 0.005 && r - dist > -0.005) {\n        return -1.0;\n    } else if (r - dist < 0.01 && r - dist > -0.005) {\n        return -2.0;\n    }\n    return grad;\n}\n\nfloat round(float a) {\n    return floor(a + 0.5);\n}\n\nfloat getWave(vec2 p){\n    vec2 _p = p - center;\n    float rads = atan(_p.y, _p.x);\n    float degs = degrees(rads) + 180.0;\n    vec2 range = vec2(0.0, M_PI * 30.0);\n    vec2 domain = vec2(0.0, 360.0);\n    \n    float ratio = (M_PI * 30.0) / 360.0;\n    degs = degs * ratio;\n    float x = progress;\n    float magnitude = mix(0.02, 0.09, smoothstep(0.0, 1.0, x));\n    float offset = mix(40.0, 30.0, smoothstep(0.0, 1.0, x));\n    float ease_degs = quadraticInOut(sin(degs));\n    \n    float deg_wave_pos = (ease_degs * magnitude) * sin(x * offset);\n    return x + deg_wave_pos;\n}\n\nvoid main() {\n  vec2 p = gl_FragCoord.xy / resolution.xy;\n  \n  if (progress == 0.0) {\n    gl_FragColor = texture2D(from, p);\n  } else if (progress == 1.0) {\n    gl_FragColor = texture2D(to, p);\n  } else {\n    float dist = distance(center, p);\n    float m = getGradient(getWave(p), dist);\n    if (m == -2.0) {\n      gl_FragColor = mix(texture2D(from, p), vec4(0.0, 0.0, 0.0, 1.0), 0.75);\n    } else {\n      gl_FragColor = mix(texture2D(from, p), texture2D(to, p), m);    \n    }\n  }\n}",
    "trans_wind": "#ifdef GL_ES\n    precision mediump float;\n#endif\n\nuniform sampler2D from;\nuniform sampler2D to;\nuniform float progress;\nuniform vec2 resolution;\nconst float size = 0.2;\n\nfloat rand (vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    float r = rand(vec2(0, p.y));\n    float m = smoothstep(0.0, -size, p.x*(1.0-size) + size*r - (progress * (1.0 + size)));\n    gl_FragColor = mix(texture2D(from, p), texture2D(to, p), m);\n}"
});});