// Webgl transition fragments

webvn.use(['webgl'], function (s, webgl) {

webgl.Transition.addTransition({
    advancedMosaic: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'void main(void)',
        '{',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'float T = progress;',
            'float S0 = 1.0;',
            'float S1 = 50.0;',
            'float S2 = 1.0;',
            'float Half = 0.5;',
            'float PixelSize = ( T < Half ) ? mix( S0, S1, T / Half ) : mix( S1, S2, (T-Half) / Half );',
            'vec2 D = PixelSize / resolution.xy;',
            'vec2 UV = ( p + vec2( -0.5 ) ) / D;',
            'vec2 Coord = clamp( D * ( ceil( UV + vec2( -0.5 ) ) ) + vec2( 0.5 ), vec2( 0.0 ), vec2( 1.0 ) );',
            'vec4 C0 = texture2D( from, Coord );',
            'vec4 C1 = texture2D( to, Coord );',
            'gl_FragColor = mix( C0, C1, T );',
        '}'
    ].join('\n'),
    butterflyWaveScrawler: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float amplitude = 1.0;',
        'const float waves = 30.0;',
        'const float colorSeparation = 0.3;',
        'float PI = 3.14159265358979323846264;',
        'float compute(vec2 p, float progress, vec2 center) {',
            'vec2 o = p*sin(progress * amplitude)-center;',
            'vec2 h = vec2(1., 0.);',
            'float theta = acos(dot(o, h)) * waves;',
            'return (exp(cos(theta)) - 2.*cos(4.*theta) + pow(sin((2.*theta - PI) / 24.), 5.)) / 10.;',
        '}',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'float inv = 1. - progress;',
            'vec2 dir = p - vec2(.5);',
            'float dist = length(dir);',
            'float disp = compute(p, progress, vec2(0.5, 0.5)) ;',
            'vec4 texTo = texture2D(to, p + inv*disp);',
            'vec4 texFrom = vec4(',
            'texture2D(from, p + progress*disp*(1.0 - colorSeparation)).r,',
            'texture2D(from, p + progress*disp).g,',
            'texture2D(from, p + progress*disp*(1.0 + colorSeparation)).b,',
            '1.0);',
            'gl_FragColor = texTo*progress + texFrom*inv;',
        '}'
    ].join('\n'),
    burn: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const vec3 color = vec3(0.9, 0.4, 0.2);',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'gl_FragColor = mix(',
                'texture2D(from, p) + vec4(progress*color, 0.0),',
                'texture2D(to, p) + vec4((1.0-progress)*color, 0.0),',
                'progress);',
        '}'
    ].join('\n'),
    crazyParametricFun: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float a = 4.0;',
        'const float b = 1.0;',
        'const float amplitude = 120.0;',
        'const float smoothness = 0.1;',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec2 dir = p - vec2(.5);',
            'float dist = length(dir);',
            'float x = (a - b) * cos(progress) + b * cos(progress * ((a / b) - 1.) );',
            'float y = (a - b) * sin(progress) - b * sin(progress * ((a / b) - 1.));',
            'vec2 offset = dir * vec2(sin(progress  * dist * amplitude * x), sin(progress * dist * amplitude * y)) / smoothness;',
            'gl_FragColor = mix(texture2D(from, p + offset), texture2D(to, p), smoothstep(0.2, 1.0, progress));',
        '}'
    ].join('\n'),
    crossHatch: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from;',
        'uniform sampler2D to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const vec2 center = vec2(0.5, 0.5);',
        'float quadraticInOut(float t) {',
            'float p = 2.0 * t * t;',
            'return t < 0.5 ? p : -p + (4.0 * t) - 1.0;',
        '}',
        'float rand(vec2 co) {',
            'return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);',
        '}',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'if (progress == 0.0) {',
                'gl_FragColor = texture2D(from, p);',
            '} else if (progress == 1.0) {',
                'gl_FragColor = texture2D(to, p);',
            '} else {',
                'float x = progress;',
                'float dist = distance(center, p);',
                'float r = x - min(rand(vec2(p.y, 0.0)), rand(vec2(0.0, p.x)));',
                'float m = dist <= r ? 1.0 : 0.0;',
                'gl_FragColor = mix(texture2D(from, p), texture2D(to, p), m);',
            '}',
        '}'
    ].join('\n'),
    directionalWipe: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from;',
        'uniform sampler2D to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const vec2 direction = vec2(1.0, -1.0);',
        'const float smoothness = 0.5;',
        'const vec2 center = vec2(0.5, 0.5);',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec2 v = normalize(direction);',
            'v /= abs(v.x)+abs(v.y);',
            'float d = v.x * center.x + v.y * center.y;',
            'float m = smoothstep(-smoothness, 0.0, v.x * p.x + v.y * p.y - (d-0.5+progress*(1.+smoothness)));',
            'gl_FragColor = mix(texture2D(to, p), texture2D(from, p), m);',
        '}'
    ].join('\n'),
    doomScreenTransition: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'float rand(int num) {',
            'return fract(mod(float(num) * 67123.313, 12.0) * sin(float(num) * 10.3) * cos(float(num)));',
        '}',
        'float wave(int num) {',
            'float fn = float(num) * 1.0 * 0.1 * float(10.0);',
            'return cos(fn * 0.5) * cos(fn * 0.13) * sin((fn+10.0) * 0.3) / 2.0 + 0.5;',
        '}',
        'float pos(int num) {',
            'return wave(num);',
        '}',
        'void main() {',
            'int bar = int(gl_FragCoord.x) / 10;',
            'float scale = 1.0 + pos(bar) * 2.0;',
            'float phase = progress * scale;',
            'float posY = gl_FragCoord.y / resolution.y;',
            'vec2 p;',
            'vec4 c;',
            'if (phase + posY < 1.0) {',
                'p = vec2(gl_FragCoord.x, gl_FragCoord.y + mix(0.0, resolution.y, phase)) / resolution.xy;',
                'c = texture2D(from, p);',
            '} else {',
                'p = gl_FragCoord.xy / resolution.xy;',
                'c = texture2D(to, p);',
            '}',
            'gl_FragColor = c;',
        '}'
    ].join('\n'),
    circleOpen: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from;',
        'uniform sampler2D to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float smoothness = 0.3;',
        'const bool opening = true;',
        'const vec2 center = vec2(0.5, 0.5);',
        'const float SQRT_2 = 1.414213562373;',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'float x = opening ? progress : 1.-progress;',
            'float m = smoothstep(-smoothness, 0.0, SQRT_2*distance(center, p) - x*(1.+smoothness));',
            'gl_FragColor = mix(texture2D(from, p), texture2D(to, p), opening ? 1.-m : m);',
        '}'
    ].join('\n'),
    colourDistance: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec4 fTex = texture2D(from,p);',
            'vec4 tTex = texture2D(to,p);',
            'gl_FragColor = mix(distance(fTex,tTex)>progress?fTex:tTex, tTex, pow(progress,5.0));',
        '}'
    ].join('\n'),
    crossZoom: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float PI = 3.141592653589793;',
        'float Linear_ease(in float begin, in float change, in float duration, in float time) {',
            'return change * time / duration + begin;',
        '}',
        'float Exponential_easeInOut(in float begin, in float change, in float duration, in float time) {',
            'if (time == 0.0)',
                'return begin;',
            'else if (time == duration)',
                'return begin + change;',
            'time = time / (duration / 2.0);',
            'if (time < 1.0)',
                'return change / 2.0 * pow(2.0, 10.0 * (time - 1.0)) + begin;',
            'return change / 2.0 * (-pow(2.0, -10.0 * (time - 1.0)) + 2.0) + begin;',
        '}',
        'float Sinusoidal_easeInOut(in float begin, in float change, in float duration, in float time) {',
            'return -change / 2.0 * (cos(PI * time / duration) - 1.0) + begin;',
        '}',
        'float random(in vec3 scale, in float seed) {',
            'return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);',
        '}',
        'vec3 crossFade(in vec2 uv, in float dissolve) {',
            'return mix(texture2D(from, uv).rgb, texture2D(to, uv).rgb, dissolve);',
        '}',
        'void main() {',
            'vec2 texCoord = gl_FragCoord.xy / resolution.xy;',
            'vec2 center = vec2(Linear_ease(0.25, 0.5, 1.0, progress), 0.5);',
            'float dissolve = Exponential_easeInOut(0.0, 1.0, 1.0, progress);',
            'float strength = Sinusoidal_easeInOut(0.0, 0.4, 0.5, progress);',
            'vec3 color = vec3(0.0);',
            'float total = 0.0;',
            'vec2 toCenter = center - texCoord;',
            'float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);',
            'for (float t = 0.0; t <= 40.0; t++) {',
                'float percent = (t + offset) / 40.0;',
                'float weight = 4.0 * (percent - percent * percent);',
                'color += crossFade(texCoord + toCenter * percent * strength, dissolve) * weight;',
                'total += weight;',
            '}',
            'gl_FragColor = vec4(color / total, 1.0);',
        '}'
    ].join('\n'),
    defocusBlur: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'uniform sampler2D from;',
        'uniform sampler2D to;',
        'void main(void) {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
        	'float T = progress;',
        	'float S0 = 1.0;',
        	'float S1 = 50.0;',
        	'float S2 = 1.0;',
        	'float Half = 0.5;',
        	'float PixelSize = ( T < Half ) ? mix( S0, S1, T / Half ) : mix( S1, S2, (T-Half) / Half );',
        	'vec2 D = PixelSize / resolution.xy;',
        	'vec2 UV = (gl_FragCoord.xy / resolution.xy);',
        	'const int NumTaps = 12;',
        	'vec2 Disk[NumTaps];',
        	'Disk[0] = vec2(-.326,-.406);',
        	'Disk[1] = vec2(-.840,-.074);',
        	'Disk[2] = vec2(-.696, .457);',
        	'Disk[3] = vec2(-.203, .621);',
        	'Disk[4] = vec2( .962,-.195);',
        	'Disk[5] = vec2( .473,-.480);',
        	'Disk[6] = vec2( .519, .767);',
        	'Disk[7] = vec2( .185,-.893);',
        	'Disk[8] = vec2( .507, .064);',
        	'Disk[9] = vec2( .896, .412);',
        	'Disk[10] = vec2(-.322,-.933);',
        	'Disk[11] = vec2(-.792,-.598);',
        	'vec4 C0 = texture2D( from, UV );',
        	'vec4 C1 = texture2D( to, UV );',
        	'for ( int i = 0; i != NumTaps; i++ )',
        	'{',
        		'C0 += texture2D( from, Disk[i] * D + UV );',
        		'C1 += texture2D( to, Disk[i] * D + UV );',
        	'}',
        	'C0 /= float(NumTaps+1);',
        	'C1 /= float(NumTaps+1);',
        	'gl_FragColor = mix( C0, C1, T );',
        '}'
    ].join('\n'),
    dispersionBlur: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        '#define QUALITY 32',
        'uniform sampler2D from;',
        'uniform sampler2D to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float GOLDEN_ANGLE = 2.399963229728653;',
        'vec4 blur(sampler2D t, vec2 c, float radius) {',
            'vec4 sum = vec4(0.0);',
            'float q = float(QUALITY);',
            'for (int i=0; i<QUALITY; ++i) {',
                'float fi = float(i);',
                'float a = fi * GOLDEN_ANGLE;',
                'float r = sqrt(fi / q) * radius;',
                'vec2 p = c + r * vec2(cos(a), sin(a));',
                'sum += texture2D(t, p);',
            '}',
            'return sum / q;',
        '}',
        'void main()',
        '{',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'float inv = 1.-progress;',
            'gl_FragColor = inv*blur(from, p, progress*0.6) + progress*blur(to, p, inv*0.6);',
        '}'
    ].join('\n'),
    dissolve: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float blocksize = 1.0;',
        'float rand(vec2 co) {',
            'return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);',
        '}',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'gl_FragColor = mix(texture2D(from, p), texture2D(to, p), step(rand(floor(gl_FragCoord.xy/blocksize)), progress));',
        '}'
    ].join('\n'),
    dreamy: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'vec2 offset(float progress, float x, float theta) {',
            'float phase = progress*progress + progress + theta;',
            'float shifty = 0.03*progress*cos(10.0*(progress+x));',
            'return vec2(0, shifty);',
        '}',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'gl_FragColor = mix(texture2D(from, p + offset(progress, p.x, 0.0)), texture2D(to, p + offset(1.0-progress, p.x, 3.14)), progress);',
        '}'
    ].join('\n'),
    dreamyZoom: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        '#define DEG2RAD 0.03926990816987241548078304229099',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'void main() {',
            'float phase = progress < 0.5 ? progress * 2.0 : (progress - 0.5) * 2.0;',
            'float angleOffset = progress < 0.5 ? mix(0.0, 6.0 * DEG2RAD, phase) : mix(-6.0 * DEG2RAD, 0.0, phase);',
            'float newScale = progress < 0.5 ? mix(1.0, 1.2, phase) : mix(1.2, 1.0, phase);',
            'vec2 center = vec2(0, 0);',
            'float maxRes = max(resolution.x, resolution.y);',
            'float resX = resolution.x / maxRes * 0.5;',
            'float resY = resolution.y / maxRes * 0.5;',
            'vec2 p = (gl_FragCoord.xy / maxRes - vec2(resX, resY)) / newScale;',
            'float angle = atan(p.y, p.x) + angleOffset;',
            'float dist = distance(center, p);',
            'p.x = cos(angle) * dist + resX;',
            'p.y = sin(angle) * dist + resY;',
            'vec4 c = progress < 0.5 ? texture2D(from, p) : texture2D(to, p);',
            'gl_FragColor = c + (progress < 0.5 ? mix(0.0, 1.0, phase) : mix(1.0, 0.0, phase));',
        '}'
    ].join('\n'),
    fadeColorBlack: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from;',
        'uniform sampler2D to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const vec3 color = vec3(0.0, 0.0, 0.0);',
        'const float colorPhase = 0.4;',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'gl_FragColor = mix(',
                'mix(vec4(color, 1.0), texture2D(from, p), smoothstep(1.0-colorPhase, 0.0, progress)),',
                'mix(vec4(color, 1.0), texture2D(to,   p), smoothstep(    colorPhase, 1.0, progress)),',
                'progress);',
            'gl_FragColor.a = mix(texture2D(from, p).a, texture2D(to, p).a, progress);',
        '}'
    ].join('\n'),
    fadeGrayscale: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from;',
        'uniform sampler2D to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float grayPhase = 0.3;',
        'vec3 grayscale (vec3 color) {',
            'return vec3(0.2126*color.r + 0.7152*color.g + 0.0722*color.b);',
        '}',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec4 fc = texture2D(from, p);',
            'vec4 tc = texture2D(to, p);',
            'gl_FragColor = mix(',
                'mix(vec4(grayscale(fc.rgb), 1.0), texture2D(from, p), smoothstep(1.0-grayPhase, 0.0, progress)),',
                'mix(vec4(grayscale(tc.rgb), 1.0), texture2D(to,   p), smoothstep(    grayPhase, 1.0, progress)),',
                'progress);',
            'gl_FragColor.a = mix(fc.a, tc.a, progress);',
        '}'
    ].join('\n'),
    flyEye: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from;',
        'uniform sampler2D to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float size = 0.04;',
        'const float zoom = 30.0;',
        'const float colorSeparation = 0.3;',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'float inv = 1. - progress;',
            'vec2 disp = size*vec2(cos(zoom*p.x), sin(zoom*p.y));',
            'vec4 texTo = texture2D(to, p + inv*disp);',
            'vec4 texFrom = vec4(',
                'texture2D(from, p + progress*disp*(1.0 - colorSeparation)).r,',
                'texture2D(from, p + progress*disp).g,',
                'texture2D(from, p + progress*disp*(1.0 + colorSeparation)).b,',
                'texture2D(from, p + progress*disp).a);',
            'gl_FragColor = texTo*progress + texFrom*inv;',
        '}'
    ].join('\n'),
    glitchDisplace: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'highp float random(vec2 co)',
        '{',
            'highp float a = 12.9898;',
            'highp float b = 78.233;',
            'highp float c = 43758.5453;',
            'highp float dt= dot(co.xy ,vec2(a,b));',
            'highp float sn= mod(dt,3.14);',
            'return fract(sin(sn) * c);',
        '}',
        'float voronoi( in vec2 x ) {',
            'vec2 p = floor( x );',
            'vec2 f = fract( x );',
            'float res = 8.0;',
            'for( float j=-1.; j<=1.; j++ )',
            'for( float i=-1.; i<=1.; i++ ) {',
                'vec2  b = vec2( i, j );',
                'vec2  r = b - f + random( p + b );',
                'float d = dot( r, r );',
                'res = min( res, d );',
            '}',
            'return sqrt( res );',
        '}',
        'vec2 displace(vec4 tex, vec2 texCoord, float dotDepth, float textureDepth, float strength) {',
            'float b = voronoi(.003 * texCoord + 2.0);',
            'float g = voronoi(0.2 * texCoord);',
            'float r = voronoi(texCoord - 1.0);',
            'vec4 dt = tex * 1.0;',
            'vec4 dis = dt * dotDepth + 1.0 - tex * textureDepth;',
            'dis.x = dis.x - 1.0 + textureDepth*dotDepth;',
            'dis.y = dis.y - 1.0 + textureDepth*dotDepth;',
            'dis.x *= strength;',
            'dis.y *= strength;',
            'vec2 res_uv = texCoord ;',
            'res_uv.x = res_uv.x + dis.x - 0.0;',
            'res_uv.y = res_uv.y + dis.y;',
            'return res_uv;',
        '}',
        'float ease1(float t) {',
            'return t == 0.0 || t == 1.0',
                '? t',
                ': t < 0.5',
                '? +0.5 * pow(2.0, (20.0 * t) - 10.0)',
                ': -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;',
        '}',
        'float ease2(float t) {',
            'return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);',
        '}',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec4 color1 = texture2D(from, p);',
            'vec4 color2 = texture2D(to, p);',
            'vec2 disp = displace(color1, p, 0.33, 0.7, 1.0-ease1(progress));',
            'vec2 disp2 = displace(color2, p, 0.33, 0.5, ease2(progress));',
            'vec4 dColor1 = texture2D(to, disp);',
            'vec4 dColor2 = texture2D(from, disp2);',
            'float val = ease1(progress);',
            'vec3 gray = vec3(dot(min(dColor2, dColor1).rgb, vec3(0.299, 0.587, 0.114)));',
            'dColor2 = vec4(gray, 1.0);',
            'dColor2 *= 2.0;',
            'color1 = mix(color1, dColor2, smoothstep(0.0, 0.5, progress));',
            'color2 = mix(color2, dColor1, smoothstep(1.0, 0.5, progress));',
            'gl_FragColor = mix(color1, color2, val);',
        '}'
    ].join('\n'),
    HSVfade: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'vec3 hsv2rgb(vec3 c) {',
            'const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);',
            'vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);',
            'return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);',
        '}',
        'vec3 rgb2hsv(vec3 c) {',
            'const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);',
            'vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));',
            'vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));',
            'float d = q.x - min(q.w, q.y);',
            'return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + 0.001)), d / (q.x + 0.001), q.x);',
        '}',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec3 a = rgb2hsv(texture2D(from, p).rgb);',
            'vec3 b = rgb2hsv(texture2D(to, p).rgb);',
            'vec3 m = mix(a, b, progress);',
            'vec4 r = vec4(hsv2rgb(m), mix(texture2D(from, p).a, texture2D(to, p).a, progress));',
            'gl_FragColor = r;',
        '}'
    ].join('\n'),
    kaleidoScope: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec2 q = p;',
            'float t = pow(progress, 2.0)*1.0;',
            'p = p -0.5;',
            'for (int i = 0; i < 7; i++) {',
                'p = vec2(sin(t)*p.x + cos(t)*p.y, sin(t)*p.y - cos(t)*p.x);',
                't += 2.0;',
                'p = abs(mod(p, 2.0) - 1.0);',
            '}',
            'abs(mod(p, 1.0));',
            'gl_FragColor = mix(',
                'mix(texture2D(from, q), texture2D(to, q), progress),',
                'mix(texture2D(from, p), texture2D(to, p), progress), 1.0 - 2.0*abs(progress - 0.5));',
        '}'
    ].join('\n'),
    linearBlur: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float intensity = 0.1;',
        'const int PASSES = 8;',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec4 c1 = vec4(0.0), c2 = vec4(0.0);',
            'float disp = intensity*(0.5-distance(0.5, progress));',
            'for (int xi=0; xi<PASSES; ++xi) {',
                'float x = float(xi) / float(PASSES) - 0.5;',
                'for (int yi=0; yi<PASSES; ++yi) {',
                    'float y = float(yi) / float(PASSES) - 0.5;',
                    'vec2 v = vec2(x,y);',
                    'float d = disp;',
                    'c1 += texture2D(from, p + d*v);',
                    'c2 += texture2D(to, p + d*v);',
                '}',
            '}',
            'c1 /= float(PASSES*PASSES);',
            'c2 /= float(PASSES*PASSES);',
            'gl_FragColor = mix(c1, c2, progress);',
        '}'
    ].join('\n'),
    morph: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float strength=0.1;',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec4 ca = texture2D(from, p);',
            'vec4 cb = texture2D(to, p);',
            'vec2 oa = (((ca.rg+ca.b)*0.5)*2.0-1.0);',
            'vec2 ob = (((cb.rg+cb.b)*0.5)*2.0-1.0);',
            'vec2 oc = mix(oa,ob,0.5)*strength;',
            'float w0 = progress;',
            'float w1 = 1.0-w0;',
            'gl_FragColor = mix(texture2D(from, p+oc*w0), texture2D(to, p-oc*w1), progress);',
        '}'
    ].join('\n'),
    polkaDots: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float dots = 5.0;',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'float x = progress;',
            'bool nextImage = distance(fract(p * dots), vec2(0.5, 0.5)) < x;',
            'if(nextImage)',
                'gl_FragColor = texture2D(to, p);',
            'else',
                'gl_FragColor = texture2D(from, p);',
        '}'
    ].join('\n'),
    polkaDotsCurtain: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float SQRT_2 = 1.414213562373;',
        'const float dots = 20.0;',
        'const vec2 center = vec2(1.0, 1.0);',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'float x = progress /2.0;',
            'bool nextImage = distance(fract(p * dots), vec2(0.5, 0.5)) < (2.0 * x / distance(p, center));',
            'if(nextImage) gl_FragColor = texture2D(to, p);',
            'else gl_FragColor = texture2D(from, p);',
        '}'
    ].join('\n'),
    radial: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        '#define PI 3.141592653589',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec2 rp = p*2.-1.;',
            'float a = atan(rp.y, rp.x);',
            'float pa = progress*PI*2.5-PI*1.25;',
            'vec4 fromc = texture2D(from, p);',
            'vec4 toc = texture2D(to, p);',
            'if(a>pa) {',
                'gl_FragColor = mix(toc, fromc, smoothstep(0., 1., (a-pa)));',
            '} else {',
                'gl_FragColor = toc;',
            '}',
        '}'
    ].join('\n'),
    randomSquares: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'float rand(vec2 co){',
            'return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);',
        '}',
        'void main() {',
            'float revProgress = (1.0 - progress);',
            'float distFromEdges = min(progress, revProgress);',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec4 fromColor = texture2D(from, p);',
            'vec4 toColor = texture2D(to, p);',
            'float squareSize = 20.0;',
            'float flickerSpeed = 60.0;',
            'vec2 seed = floor(gl_FragCoord.xy / squareSize) * floor(distFromEdges * flickerSpeed);',
            'gl_FragColor = mix(fromColor, toColor, progress) + rand(seed) * distFromEdges * 0.5;',
        '}'
    ].join('\n'),
    randomSquares2: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from;',
        'uniform sampler2D to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const ivec2 size = ivec2(10.0, 10.0);',
        'const float smoothness = 0.5;',
        'float rand (vec2 co) {',
            'return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);',
        '}',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'float r = rand(floor(vec2(size) * p));',
            'float m = smoothstep(0.0, -smoothness, r - (progress * (1.0 + smoothness)));',
            'gl_FragColor = mix(texture2D(from, p), texture2D(to, p), m);',
        '}'
    ].join('\n'),
    ripple: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from;',
        'uniform sampler2D to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float amplitude = 100.0;',
        'const float speed = 50.0;',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec2 dir = p - vec2(.5);',
            'float dist = length(dir);',
            'vec2 offset = dir * (sin(progress * dist * amplitude - progress * speed) + .5) / 30.;',
            'gl_FragColor = mix(texture2D(from, p + offset), texture2D(to, p), smoothstep(0.2, 1.0, progress));',
        '}'
    ].join('\n'),
    squareSwipe: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from, to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const ivec2 squares = ivec2(10.0, 10.0);',
        'const vec2 direction = vec2(1.0, -0.5);',
        'const float smoothness = 1.6;',
        'const vec2 center = vec2(0.5, 0.5);',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'vec2 v = normalize(direction);',
            'if (v != vec2(0.0))',
                'v /= abs(v.x)+abs(v.y);',
            'float d = v.x * center.x + v.y * center.y;',
            'float offset = smoothness;',
            'float pr = smoothstep(-offset, 0.0, v.x * p.x + v.y * p.y - (d-0.5+progress*(1.+offset)));',
            'vec2 squarep = fract(p*vec2(squares));',
            'vec2 squaremin = vec2(pr/2.0);',
            'vec2 squaremax = vec2(1.0 - pr/2.0);',
            'float a = all(lessThan(squaremin, squarep)) && all(lessThan(squarep, squaremax)) ? 1.0 : 0.0;',
            'gl_FragColor = mix(texture2D(from, p), texture2D(to, p), a);',
        '}'
    ].join('\n'),
    squeeze: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from;',
        'uniform sampler2D to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float colorSeparation = 0.02;',
        'float progressY (float y) {',
            'return 0.5 + (y-0.5) / (1.0-progress);',
        '}',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'float y = progressY(p.y);',
            'if (y < 0.0 || y > 1.0) {',
                'gl_FragColor = texture2D(to, p);',
            '}',
            'else {',
                'vec2 fp = vec2(p.x, y) + progress*vec2(0.0, colorSeparation);',
                'vec4 c = vec4(',
                    'texture2D(from, fp).r,',
                    'texture2D(from, fp).g,',
                    'texture2D(from, fp).b,',
                    'texture2D(from, fp).a',
                    ');',
                'gl_FragColor = c;',
                'if (c.a == 0.0) {gl_FragColor = texture2D(to, p);}',
            '}',
        '}'
    ].join('\n'),
    wind: [
        '#ifdef GL_ES',
        'precision highp float;',
        '#endif',
        'uniform sampler2D from;',
        'uniform sampler2D to;',
        'uniform float progress;',
        'uniform vec2 resolution;',
        'const float size = 0.2;',
        'float rand (vec2 co) {',
            'return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);',
        '}',
        'void main() {',
            'vec2 p = gl_FragCoord.xy / resolution.xy;',
            'float r = rand(vec2(0, p.y));',
            'float m = smoothstep(0.0, -size, p.x*(1.0-size) + size*r - (progress * (1.0 + size)));',
            'gl_FragColor = mix(texture2D(from, p), texture2D(to, p), m);',
        '}'
    ].join('\n')
});

});